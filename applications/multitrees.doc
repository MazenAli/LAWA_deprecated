:document:    lawa::applications::multitrees

Multitree based algorithms (Chapters 6 and 7)
=============================================

We describe the realization of the multitree-based algorithms from Chapters  6 and 7. We start with tree structures and required routines.

Tree structured index sets and required routines
------------------------------------------------

In Chapter 6 and 7, our tensor product bases are composed of univariate uniformly local, piecewise polynomial wavelet bases $\Psi$ which can be written as follows

___ LATEX ________________
   \Psi = \bigcup_{j \in \mathbb{N}_0} \Psi_j, \qquad \Psi_0 := \Phi_1,
___________________________

where

___ LATEX ________________
   \Psi_j = \{ \psi_{j,k} : k \in \mathcal{J}_j \}
___________________________

and where

___ LATEX ________________
   \Phi_j = \{ \phi_{j,k} : k \in \mathcal{I}_j \}
___________________________

for $j \in \mathbb{N}$ corresponds to the collection of scaling functions on level $j$ associated to the wavelet basis $\Psi$.

The evaluation schemes $\textbf{EvalS}$, $\textbf{EvalU}$ and $\textbf{EvalL}$ are (mainly) based on the refinement of scaling functions $\phi_{j,k}$ and wavelets $\psi_{j,k}$ in terms of scaling functions on level $j+1$, i.e.,

___ LATEX ________________
   \Psi_j^\top = \Phi_{j+1} \mathrm{M}_{j,1}, \qquad \Phi_j^\top = \Phi_{j+1} \mathrm{M}_{j,0}.
___________________________

for refinement matrices $\mathrm{M}_{j,0}$ and $\mathrm{M}_{j,1}$.

In order to obtain an efficient numerical scheme, the elements of $\Phi_j$ (for which we evaluate underlying bilinear forms) should be "easy to handle". For standard basis constructions, the scaling functions are B-Splines which do not impose any problems. For multiwavelet basis, however, we have multiple types of scaling functions whose distinction is computationally costly. To this end, furthermore, we also consider so-called uniformly local, piecewise polynomial `refinement bases`

___ LATEX ________________
   \bar\Phi_j = \{ \bar\phi_{j,k} : k \in \bar{\mathcal{J}}_j \}
___________________________

for $j = j_0, j_0+1, \ldots$ for a certain $j_0>0$ such that

___ LATEX ________________
\begin{align*}
  & \Psi_j^\top = \bar{\mathrm{M}}_{j,1} \bar{\Phi}_{j+j_0+1}, \qquad \Phi_j^\top = \bar{\mathrm{M}}_{j,0} \bar{\Phi}_{j+j_0+1}\\
  & \mathrm{span}\bar{\Phi}_{j+j_0+1} \supseteq \mathrm{span} \Phi_j \cup \Psi_j
\end{align*}
___________________________

for refinement matrices $\bar{\mathrm{M}}_{j,0}$ and $\bar{\mathrm{M}}_{j,1}$. For our purposes, we may always think of $\bar{\Phi}_j$ as a collections of B-Splines to which we shall also refer to as `refinement B-Splines`.

It is important to note, as we shall also see below, that the adoption of the algorithms $\textbf{EvalS}$, $\textbf{EvalU}$ and $\textbf{EvalL}$ to this slightly extended setting is straightforward.

In order to set up, test and understand the tree structure of one-dimensional index sets (or, respectively, coefficient vectors), we have the following test programs:

- __Refinements and neighbors__ (of scaling functions, wavelets and refinement B-Splines)

:links:  __Refinements and neighbors__ -> lawa::applications::multitrees::testlocalrefinement